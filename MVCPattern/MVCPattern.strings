
/*
  MVCPattern.strings
  DesignPatterns

  Created by 刘永杰 on 2019/5/12.
  Copyright © 2019 刘永杰. All rights reserved.
 
 复合模式之王 - MVC 设计模式
 
 Model - View - Controller
 模型 - 视图 - 控制器
 
 MVC 是数个设计模式结合起来的模式
 
 视图：用来呈现模型。视图通常直接从模型中取得它需要显示的状态与数据
 控制器：取得用户的输入并解读其对模型的意思
 模型：模型持有所有的数据、状态和程序逻辑。模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者
 
        Controller
        / 控制器  \
       /          \ ➋
    1 / ➌          \
     /              \
    /       ➍        \
 View <- - - - - -> Model
 视图        ➎       模型
 
 1：V -> C 用户做某件事：视图是模型的窗口。当你对视图做一些事时，视图就告诉控制器你做了什么。控制器会负责处理
 
 ➋：C -> M 改变状态：控制器解读你的动作。如果你按下某个按钮，控制器会理解这个动作的意义，并告知模型如何做出对应的动作
 
 ➌：C -> V 改变显示：当控制器从视图接收到某一个动作，结果可能是它也需要告诉视图改变其结果。比方说，控制器可以将界面上的某些按钮或菜单项变成有效或无效
 
 ➍：M -> V 我改变了！：不管是你做了某些动作（比方说按下按钮）还是内部有了某些改变（比方说播放清单的下一首歌开始），只要当模型内的东西改变时，模型都会通知视图它的状态改变了
 
 ➎：V -> M 我需要你的状态信息：视图直接从模型取得它显示的状态。比方说，当模型通知视图新歌开始播放，视图向模型询问歌名并显示出来。当控制器请求视图改变时，视图也可能向模型询问某些状态
 
 问答：
 问：控制器所做的事情就是把用户输入从视图发送到模型，对不对？如果只是做这些事，其实控制器没有必要存在呀！为何不把这样的代码放在视图中？大多数情况下，控制器不是只调用模型的方法吗？
 答：控制器做的事情不只有”发送给模型“，还会解读输入，并根据输入操纵模型。你真正想问的问题可能是”为何不把这样的代码放在视图中？“ 你当然可以这么做，但是你不想这么做，有两个原因：首先，这会让视图的代码变得更复杂，因为这样一来视图的代码变得更复杂，因为这样一来视图就有两个责任，不但要管理用户界面，还要处理如何控制模型的逻辑。第二个原因，这么做将造成模型和视图之间紧耦合，如果你想复用此视图来处理其他模型，根本不可能。控制器吧控制逻辑从视图中分离，让模型和视图之间解耦。通过保持控制器和视图之间的松耦合，设计就更有弹性而且容易扩展，足以容纳以后的改变
 
 
 MVC模式用了哪些设计模式呢？
 1. 策略模式：视图(View)和控制器(Controller)实现了经典的策略模式：视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略。视图只关心系统中可视的部分，对于任何界面行为，都委托给控制器处理。使用策略模型也可以让视图和模型之间的关系解耦，因为控制器负责和模型交互来传递用户的请求。对于工作是怎么完成的，视图毫不知情
 
 视图委托控制器来处理用户动作
 视图只关注表现，控制器关注把用户输入转为模型上的行为
 对于视图来说，控制器是策略，也就是只要如何处理用户动作的对象，想换另一种行为？换掉控制器就可以了
 
 2. 观察者模式：模型(Model)实现了观察者模式，当状态改变时，相关对象将持续更新。使用观察者模式，可以让模型完全独立于视图和控制器。同一个模型可以使用不同的视图，甚至可以同时使用多个视图
 
 可观察者：Model
 观察者：View、Controller、View
 对模型状态改变有兴趣的对象，会向模型注册成为观察者（比如某些视图、控制器）
 模型对视图和控制器没有依赖，也就是没有引用。但是反向是依赖的
 
 3. 组合模式：显示包含了窗口、面板、按钮、文本标签等。每个显示组件如果不是组合节点（例如窗口），就是叶节点（例如按钮）。当控制器告诉视图更新时，只需告诉视图最顶层的组件即可，组合会处理其余的事
 
 视图是GUI组件（标签、窗口、文本输入等）的组合。顶层的组件包含其他组件，直到页节点
 
*/
