/* 
  DecoratePattern.strings
  DesignPatterns

  Created by 刘永杰 on 2018/12/6.
  Copyright © 2018 刘永杰. All rights reserved.
 
 装饰者模式 - 结构型模式
 
 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
 
 角色：组件接口或抽象类（Component）、具体的组件、继承自Component的修饰接口或抽象类（Decorate）、具体的修饰。
 
 理解：修饰接口Decorate继承自Component，并持有一个Component的引用，所以起到了复用Component并增加新的功能。可以动态的给具体组件增加额外功能。
 
 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
 
 什么时候用？
 
 1. 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。比如，其他对象的跑的行为都是50迈速度，但是目前有一个对象需要80迈的速度，使用一个装饰者来装饰，动态添加速度。
 2.想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者对类的每个行为的扩展，都支持每种组合，将产生大量的类。
 
 通俗的理解：就是目前有个类，生成的对象在其他地方都用的很多，但是这次产品需求增加了一个功能，只在某个地方使用，在不修改整个类的情况下如何做呢，就是装饰者模式，新建一个装饰者，内部引用这个类的对象，这时候就拥有了这个对象的所有成员变量和行为，增加一个行为方法。当然，使用的时候还是用原先的类生产对象，然后使用装饰者包装一下，也就是，生成一个装饰者对象把原先的对象传入，返回一个继承于原对象的装饰者类，其实这里的类型已经变了，但是我们这里不考虑强类型判断。这时原对象就拥有了新的行为。做了这么多，原对象的类没有修改，但是增加了一个行为，只是增加了一层装饰而已，就是这么简单，也就实现了一个设计原则：对扩展开放，对修改关闭。
 
*/
